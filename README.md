# one-binding
> ButterKnife依赖注入简单实现，仅供学习了解原理使用。


### 原理流程图：

![](http://img.blog.csdn.net/20160910220340068)


### 项目参考ButterKnife，对应结构为：

- onebinding-annotation: 定义的相关注解
- onebinding-api: Android API
- onebinding-compiler: 注解处理器相关
- onebinding-app: 使用示例

### ButerrKnife工作流程：

当我们开始添加相应的注解开始编译后，ButterKnife中的注解处理器ButterKnifeProcessor类中的process()方法会执行一下操作:

- 编译器会扫描Java代码中所有已定义的注解
- 当发现一个类中有任意一个注解时，ButterKnifeProcessor会生成一个新的Java类，名字为「xx_ViewBinding.java」，这个新的类实现了ViewBinder接口
- 新生成的ViewBinding类包含了每个注解对应的代码，如@BindView对应的注解在新新城的类中的bind()方法中添加了findViewById()相关代码
- 当程序运行时，会加载对应类中bind()方法中的代码


### @BindView处理示例:

```
// Process each @BindView element.
for (Element element : env.getElementsAnnotatedWith(BindView.class)) {
  // we don't SuperficialValidation.validateElement(element)
  // so that an unresolved View type can be generated by later processing rounds
  try {
    parseBindView(element, builderMap, erasedTargetNames);
  } catch (Exception e) {
    logParsingError(element, BindView.class, e);
  }
}


private void parseBindView(Element element, Map<TypeElement, BindingSet.Builder> builderMap,
      Set<TypeElement> erasedTargetNames) {
    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();

	// 检查用户输入合法性
    // Start by verifying common generated code restrictions.
    boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, "fields", element)
        || isBindingInWrongPackage(BindView.class, element);

    // Verify that the target type extends from View.
    TypeMirror elementType = element.asType();
    if (elementType.getKind() == TypeKind.TYPEVAR) {
      TypeVariable typeVariable = (TypeVariable) elementType;
      elementType = typeVariable.getUpperBound();
    }
    Name qualifiedName = enclosingElement.getQualifiedName();
    Name simpleName = element.getSimpleName();
    if (!isSubtypeOfType(elementType, VIEW_TYPE) && !isInterface(elementType)) {
      if (elementType.getKind() == TypeKind.ERROR) {
        note(element, "@%s field with unresolved type (%s) "
                + "must elsewhere be generated as a View or interface. (%s.%s)",
            BindView.class.getSimpleName(), elementType, qualifiedName, simpleName);
      } else {
        error(element, "@%s fields must extend from View or be an interface. (%s.%s)",
            BindView.class.getSimpleName(), qualifiedName, simpleName);
        hasError = true;
      }
    }

	// 异常注解返回不再继续执行
    if (hasError) {
      return;
    }

    // Assemble information on the field.
    int id = element.getAnnotation(BindView.class).value();

    // 尝试先从缓存中获取
    BindingSet.Builder builder = builderMap.get(enclosingElement);
    QualifiedId qualifiedId = elementToQualifiedId(element, id);
    if (builder != null) {
      String existingBindingName = builder.findExistingBindingName(getId(qualifiedId));
      if (existingBindingName != null) {
        error(element, "Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)",
            BindView.class.getSimpleName(), id, existingBindingName,
            enclosingElement.getQualifiedName(), element.getSimpleName());
        return;
      }
    } else {
      builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
    }

    // 将新生成的FieldViewBinding实体放入待构建集合中
    String name = simpleName.toString();
    TypeName type = TypeName.get(elementType);
    boolean required = isFieldRequired(element);

    builder.addField(getId(qualifiedId), new FieldViewBinding(name, type, required));

    // Add the type-erased version to the valid binding targets set.
    erasedTargetNames.add(enclosingElement);
  }

```